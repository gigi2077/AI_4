### **Project Purpose**

The primary goal of this project is to enhance public access to and understanding of important civic information. By leveraging a powerful AI model, the application provides a user-friendly, natural language interface for querying a specific document detailing alleged high-level corruption cases in Georgia. This tool is designed for citizens, journalists, and researchers, allowing them to ask questions and receive answers that are drawn exclusively from the provided text. This ensures that the information is presented without external bias or interpretation, making it a reliable resource for engaging with this critical data.

---

### **Technical Analysis of the Application**

This document provides a detailed analysis of the files that constitute the "Ask About Georgian Corruption Cases" application. The application is a simple, self-contained web tool that allows users to ask questions about a specific text and receive answers generated by an AI model.

---

### **Application Workflow**

The overall functionality of the application can be visualized as follows:

```mermaid
graph TD
    subgraph "Application Workflow"
        B{User opens Index.html in browser};
        B --> C[Web page UI is displayed];
        C --> D{User types a question and clicks "Ask"};
        D --> E[JavaScript function is triggered];
        E --> G{Script fetches text from data.txt};
        G --> H{Script constructs a prompt for the AI};
        H --> I[Sends request to Google Gemini API];
        I --> J{AI generates an answer based on the provided text};
        J --> K[JavaScript receives the AI response];
        K --> L{Answer is displayed on the web page};
    end

    subgraph "Data Update Process (Automated)"
        M[Netlify build process triggers update_data.py] --> N{Script fetches article from URL};
        N --> O{Parse HTML and extract content};
        O --> P{Convert to Markdown};
        P --> Q[Overwrite data.txt];
    end

    subgraph "Browser"
        B
        C
        D
        E
        G
        H
        K
        L
    end

    subgraph "Google Cloud"
        I
        J
    end
```

---

### **File-by-File Analysis**

#### 1. `Index.html`

*   **Purpose**: This file is the core of the user interface. It provides the structure, styling, and client-side logic for the application.
*   **Functionality**:
    *   **Structure (HTML)**: It defines the elements of the page, including a title, a text area for user input (`<textarea id="question-input">`), a button to submit the question (`<button id="ask-button">`), and a `div` to display the answer (`<div id="answer-box">`).
    *   **Styling (CSS)**: The `<style>` block contains CSS rules to provide a clean, modern, and responsive layout for the application.
    *   **Logic (JavaScript)**: The `<script>` block contains the application's logic.
        1.  It includes the `config.js` file to get the API key.
        2.  It adds an event listener to the "Ask" button.
        3.  When the button is clicked, it retrieves the user's question.
        4.  It fetches the content of `data.txt`.
        5.  It constructs a detailed prompt for the Google Gemini API, combining the user's question with the content from `data.txt` and a set of strict instructions for the AI.
        6.  It sends this prompt to the Gemini API using the `fetch()` function.
        7.  It processes the JSON response from the API and displays the generated answer in the answer box.
        8.  It includes error handling for API key issues, empty questions, and network/API errors.
        9.  A `linkifyURLs` function is included to convert URLs in the response into clickable links.

#### 2. `config.js`

*   **Purpose**: This file stores the API key required to authenticate with the Google Gemini API.
*   **Functionality**: It declares a single JavaScript constant, `API_KEY`, and assigns the API key string to it. Separating the API key into a configuration file is a good practice for several reasons:
    *   **Security**: It makes it easy to exclude the file from version control (e.g., using a `.gitignore` file) to prevent the key from being exposed publicly.
    *   **Maintainability**: The key can be updated in one place without modifying the application's core logic in `Index.html`.

#### 3. `data.txt`

*   **Purpose**: This file serves as the knowledge base for the AI.
*   **Functionality**: It contains the full text from a `transparency.ge` article, which is the sole source of information for the application. The JavaScript in `Index.html` fetches this text and includes it in the prompt sent to the AI. This ensures that the AI's answers are based *exclusively* on the content of this file, as mandated by the prompt instructions, rather than its general knowledge. This is a key aspect of the application's design, making it a specialized tool for querying this specific document.
*   **Source Article**:
    *   **Title**: მაღალი დონის კორუფციის სავარაუდო შემთხვევები — განახლებადი სია
    *   **URL**: [https://transparency.ge/ge/blog/magali-donis-korupciis-savaraudo-shemtxvevebi-ganaxlebadi-sia](https://transparency.ge/ge/blog/magali-donis-korupciis-savaraudo-shemtxvevebi-ganaxlebadi-sia)

#### 4. `update_data.py`

*   **Purpose**: This Python script automates the process of keeping the `data.txt` file up-to-date with the latest content from the source article.
*   **Functionality**:
    *   **Fetching**: It sends an HTTP request to the specified URL of the Transparency International Georgia article.
    *   **Parsing**: It uses the `BeautifulSoup` library to parse the HTML of the page. It is specifically programmed to find the `<div>` element containing the main article, ensuring that only relevant content is extracted.
    *   **Conversion**: The script then converts the cleaned HTML into Markdown format using the `markdownify` library.
    *   **Saving**: The resulting Markdown text is written to `data.txt`, overwriting the previous content.
*   **Execution**: This script is automatically executed during the Netlify build process, as specified in the `netlify.toml` file. This ensures that the `data.txt` file is always up-to-date with the latest content from the source article before the site is deployed.

---

### **How to Run the Application Locally**

To test the application and its AI functionality, you need to run it on a local web server. Opening the `Index.html` file directly in your browser will prevent the application from loading the necessary data due to browser security policies (CORS).

**Prerequisites:**
*   You must have Python installed on your system. You can check if you have it by opening a terminal or command prompt and typing `python --version`.

**Steps:**
1.  Open a terminal or command prompt in the project's root directory (the folder containing `Index.html`).
2.  Run the following command:
    ```bash
    python -m http.server 8000
    ```
3.  Once the server is running, open your web browser and navigate to the following address:
    [http://localhost:8000](http://localhost:8000)

This will launch the application, and all features, including the AI-powered Q&A, will be fully functional.

---

### **Conclusion**

The application is a well-structured, single-page web application that leverages a powerful AI model to provide a natural language interface for a specific text document. The separation of concerns is clear: `Index.html` for the frontend, `config.js` for configuration, and `data.txt` for the data. The detailed prompt engineering in the JavaScript code is critical to ensuring the AI provides relevant, accurate, and correctly formatted answers in the desired language.